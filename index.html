<!DOCTYPE html>
<meta charset="utf-8">
<style>

	svg {
		background-image: url("m31.jpg");
		background-size: 100%;
	}

	.links {
	  stroke: #000;
	  stroke-opacity: 0.5;
	}

	.polygons {
		fill: #DDD;
		fill-opacity: 0.2;
		stroke: #FFF;
		stroke-opacity:.1;
		pointer-events: all;
	}
	.sites {
		fill: #000;
		stroke: #fff;
	}

	.teamRed {
		fill: red;
	}

	.teamBlue {
		fill: blue;
	}

	.teamGreen {
		fill: green;
	}

	.teamYellow {
		fill: yellow;
	}

	.teamCyan {
		fill: darkcyan;
	}

	.teamPurple {
		fill: darkmagenta;
	}

	.teamOrange {
		fill: darkorange;
	}

	.teamBrown {
		fill: saddlebrown;
	}
</style>

<svg width="960" height="640"></svg>
<div id="details"></div>
<div id="logger"></div>
<script src="https://d3js.org/d3.v4.min.js"></script>

<script>

var polygons, link, site, voronoi, sites, diagram;
var xNormA, yNormA, xNormB, yNormB;
var svg, viewWidth, viewHeight, width, height, scaleX, scaleY;

//log messages to console and to the view
function log(msg) {
	var logger = document.getElementById("logger");
	logger.innerHTML = logger.innerHTML + "<br/>" + msg;
	console.log(msg);
}

//returns a function that generates in a given distribution
function gaussian(mean, stdev) {
    var y2;
    var use_last = false;
    return function() {
        var y1;
        if(use_last) {
           y1 = y2;
           use_last = false;
        }
        else {
            var x1, x2, w;
            do {
                 x1 = 2.0 * Math.random() - 1.0;
                 x2 = 2.0 * Math.random() - 1.0;
                 w  = x1 * x1 + x2 * x2;               
            } while( w >= 1.0);
            w = Math.sqrt((-2.0 * Math.log(w))/w);
            y1 = x1 * w;
            y2 = x2 * w;
            use_last = true;
       }

       var retval = mean + stdev * y1;
       if(retval > 0) 
           return retval;
       return -retval;
   }
}

//pick out points in a distribution that looks nice
function pointGen() {
	var point;
	if(Math.random() < .5) {
		point = [xNormA(), yNormA()]
	} else {
		point = [xNormB(), yNormB()]
	}
	return point;
}

//for each faction, start in a random location and expand from there
function assignFactions() {
	var factionsColors = ['teamRed', 'teamBlue', 'teamGreen', 'teamYellow', 'teamOrange', 'teamCyan', 'teamPurple', 'teamBrown']
	factionsColors.forEach(function (color) {
		var faction = generateFaction(color);
		var index;
		while(!index) {
			index = Math.floor(Math.random() * diagram.cells.length);
			var cell = diagram.cells[index];
			if (cell.faction) {
				index = undefined;
			}
		}
		assignFaction(index, faction, .9, .35);
	});
}

//Pick two aspects, making sure they don't conflict
function generateFaction(color) {
	var aspects = generateAspects(getFactionAspects(), 2);
	return {color: color, aspects: aspects};
}

function generateAspects(list, count) {
	var aspects = [];
	while(aspects.length < count) {
		var aspect = selectAspect(list);
		for(var i=0; i< aspects.length; i++){
			if(aspects[i].name == aspect.name) {
				aspect = null;
				break;
			}
			for(var j=0; j<aspects[i].excludes.length; j++) {
				if( aspects[i].excludes[j] == aspect.name ) {
					aspect = null;
					break;
				}
			}
			if(aspect == null) break;
		}
		if(aspect !== null) {
			aspects.push(aspect);
		}
	};
	return aspects;
}

function selectAspect(aspects) {
	return aspects[Math.floor(Math.random() * aspects.length)];
}

//assign a faction to a cell, given by 'index'
//expand with a chance of 'expantion' to any given adjacent cells
//decrease rate of expantion by 'decrement'
function assignFaction(index, faction, expantion, decrement) {
	var cell = diagram.cells[index];
	//randomly assign a faction, for now one of two
	if(cell.faction) return;
	cell.site.faction = faction;
	polygons._groups[0][index].setAttribute("class", faction.color);
	//now, with a random chance, pick an adjacent cell and apply the faction if it doesn't have one
	cell.halfedges.forEach(function(hEdge) {
		//var hEdge = cell.halfedges[hEdgeIndex];
		//log("exploring cell " +index+" edge "+hEdgeIndex);
		if(Math.random() < expantion) {
			var edge = diagram.edges[hEdge];
			//find neighbor that is not the current cell
			var neighbor = edge.left;
			if (neighbor === cell.site || !neighbor){ 
				neighbor = edge.right;
			}
			//if we have a neighbor
			if(neighbor) {
				assignFaction(neighbor.index, faction, expantion * decrement, decrement);
			}
		}
	});
}

//for each cell, pick three random descriptions
function assignDescriptions() {
	diagram.cells.forEach(function (cell) {
		var site = cell.site;
		//pick three aspects per site
		var planetAspects = generateAspects(getPlanetAspects(), 3);
		var raceAspects = generateAspects(getRaceAspects(),3);
		site.planet = planetAspects;
		site.race = raceAspects;
	});
}

function init() {
	//view variables
	svg 		= d3.select("svg");
	viewWidth	= svg.attr("width");
	viewHeight	= svg.attr("height");
	width		= 1536;
	height		= 1024;
	scaleX		= viewWidth/width;
	scaleY		= viewHeight/height;
	voronoiRadius = width/10;

	//Two distrubutions make it look interesting
	xNormA = gaussian(width/2 + width/8, width/10);
	yNormA = gaussian(height/2 - height/7, height/10);
	xNormB = gaussian(width/2 - width/8, width/10);
	yNormB = gaussian(height/2 + height/7, height/10);

	//main diagram references
	sites = d3.range(200).map(pointGen);
	voronoi = d3.voronoi().extent([[-1,-1], [width+1, height+1]]);
	diagram = voronoi(sites);

	//init the view
	link = svg.append("g")
		.attr("class", "links")
		.selectAll("line")
		.data(voronoi.links(sites))
		.enter()
		.append("line")
		.call(redrawLink);
	site = svg.append("g")
		.attr("class", "sites")
		.selectAll("circle")
		.data(sites)
		.enter()
		.append("circle")
		.attr("r", 2.5)
		.call(redrawSite);
	polygons = svg.append("g")
		.attr("class", "polygons")
		.selectAll("path")
		.data(voronoi.polygons(sites))
		.enter()
		.append("path")
		.call(redrawPolygon);

	assignFactions();
	assignDescriptions();
}

//draw a region
function redrawPolygon(polygon) {
	//console.log(polygon);
	polygon.attr("d", function(d) {
		return d ? "M" + d.map(function(i) {
				return [i[0]*scaleX, i[1]*scaleY];
			}).join("L") + "Z" : null;
		})
		.on("mouseover", function() { this.setAttribute("style", "fill-opacity: .5"); })
		.on("mouseout", function() { this.setAttribute("style", "fill-opacity: .2"); })
		.on("mousedown", showDetails);
}
//draw a star lane
function redrawLink(link) {
	link
		.attr("x1", function(d) { return d.source[0]*scaleX; })
		.attr("y1", function(d) { return d.source[1]*scaleY; })
		.attr("x2", function(d) { return d.target[0]*scaleX; })
		.attr("y2", function(d) { return d.target[1]*scaleY; });
}
//draw a star/planet
function redrawSite(site) {
	site
		.attr("cx", function(d) { return d[0]*scaleX; })
		.attr("cy", function(d) { return d[1]*scaleY; });
}

//show the descriptions on the page
function showDetails() {
	//rescale the input coordinates to the graph coordinates
	var site = diagram.find(d3.mouse(this)[0]/scaleX, d3.mouse(this)[1]/scaleY);
	var detailsElem = document.getElementById("details");
	var planet = "Planet: "+site.planet.map(aspect=> aspect.name).join(", ");
	var race = "<br/>Race: "+site.race.map(aspect=> aspect.name).join(", ");
	var details = planet + race;
	if(site.faction) {
		details += "<br/>Faction: " + site.faction.aspects.map(aspect => aspect.name).join(", ");
	}
	detailsElem.innerHTML = details;
}

function getFactionAspects() {
	return [
	{name:'industrialized', excludes:['primitive']},
	{name:'primitive', excludes:['industrialized']},
	{name:'monarchy', excludes:[]},
	{name:'agressive', excludes:['peaceful']},
	{name:'peaceful', excludes:['agressive']},
	{name:'democracy', excludes:[]},
	{name:'religious', excludes:[]},
	{name:'scientists', excludes:[]},
	{name:'authoritarian', excludes:['democracy']},
	{name:'confederation', excludes:['empire', 'hegemony']},
	{name:'empire', excludes:['hegemony', 'confederation']},
	{name:'hegemony', excludes:['empire', 'confederation']},
	{name:'theocracy', excludes:[]},
	];
}

function getPlanetAspects() {
	return [
	{name:'high gravity', excludes:['normal gravity', 'low gravity']},
	{name:'normal gravity', excludes:['high gravity', 'low gravity']},
	{name:'low gravity', excludes:['normal gravity', 'high gravity']},
	{name:'outpost', excludes:['colony','homeworld']},
	{name:'colony', excludes:['outpost','homeworld']},
	{name:'homeworld', excludes:['outpost','colony']},
	{name:'desert', excludes:['swamp','oceans','icy','water-covered','underwater','jungle','forest','asteroid','gas giant']},
	{name:'swamp', excludes:['desert','oceans','icy','water-covered','underwater','jungle','forest','asteroid','gas giant']},
	{name:'oceans', excludes:['desert','swamp','icy','water-covered','underwater','jungle','forest','asteroid','gas giant']},
	{name:'icy', excludes:['desert','swamp','oceans','water-covered','underwater','jungle','forest','asteroid','gas giant']},
	{name:'water-covered', excludes:['desert','swamp','oceans','icy','underwater','jungle','forest','asteroid','gas giant']},
	{name:'underwater', excludes:['desert','swamp','oceans','icy','water-covered','jungle','forest','asteroid','gas giant']},
	{name:'jungle', excludes:['desert','swamp','oceans','icy','water-covered','underwater','forest','asteroid','gas giant']},
	{name:'forest', excludes:['desert','swamp','oceans','icy','water-covered','underwater','jungle','asteroid','gas giant']},
	{name:'asteroid', excludes:['moon','gas giant','desert','swamp','oceans','water-covered','underwater','jungle','forest']},
	{name:'moon', excludes:['asteroid','gas giant']},
	{name:'gas giant', excludes:['asteroid','moon','desert','swamp','oceans','water-covered','underwater','jungle','forest']},
	{name:'capitol', excludes:['outpost','colony']},
	{name:'tidaly-locked', excludes:[]},
	];
}

function getRaceAspects() {
	return [
	{name:'industrialized', excludes:['agrarian']},
	{name:'mechanized', excludes:['agrarian', 'arborial', 'plant shaper']},
	{name:'agrarian', excludes:['industrialized','mechanized']},
	{name:'peaceful', excludes:['agressive']},
	{name:'agressive', excludes:['peaceful']},
	{name:'xenophobic', excludes:['xenophile']},
	{name:'xenophile', excludes:['xenophobic']},
	{name:'welcoming', excludes:[]},
	{name:'wealthy', excludes:['poor']},
	{name:'poor', excludes:['wealthy']},
	{name:'monarchy', excludes:['democracy', 'confederation', 'anarchy', 'theocracy']},
	{name:'democracy', excludes:['monarchy', 'confederation', 'anarchy', 'theocracy']},
	{name:'confederation', excludes:['monarchy', 'democracy', 'anarchy', 'theocracy']},
	{name:'anarchy', excludes:['monarchy', 'democracy', 'confederation', 'theocracy']},
	{name:'theocracy', excludes:['monarchy', 'democracy', 'confederation', 'anarchy']},
	{name:'religious', excludes:[]},
	{name:'ecologist', excludes:[]},
	{name:'pacifist', excludes:[]},
	{name:'authoritarian', excludes:[]},
	{name:'scientists', excludes:[]},
	{name:'greedy', excludes:['communistic']},
	{name:'communistic', excludes:['greedy']},
	{name:'spacefaring', excludes:[]},
	{name:'robotic', excludes:['bioengeered', 'arborial','plant shaper']},
	{name:'bioengeered', excludes:['robotic','arborial']},
	{name:'arborial', excludes:['robotic','bioengeered']},
	{name:'plant shaper', excludes:['robotic','mechanized']},

	];
}

window.onload = function() { init(); };

</script>
