<!DOCTYPE html>
<meta charset="utf-8">
<style>

	svg {
		background-image: url("m31.jpg");
		background-size: 100%;
	}

	.links {
	  stroke: #000;
	  stroke-opacity: 0.5;
	}

	.polygons {
		fill: #DDD;
		fill-opacity: 0.2;
		stroke: #FFF;
		stroke-opacity:.1;
		pointer-events: all;
	}
	.sites {
		fill: #000;
		stroke: #fff;
	}

	.teamRed {
		fill: red;
	}

	.teamBlue {
		fill: blue;
	}

	.teamGreen {
		fill: green;
	}

	.teamYellow {
		fill: yellow;
	}

	.teamCyan {
		fill: darkcyan;
	}

	.teamPurple {
		fill: darkmagenta;
	}

	.teamOrange {
		fill: darkorange;
	}

	.teamBrown {
		fill: saddlebrown;
	}
</style>

<svg width="960" height="500"></svg>
<div id="details"></div>
<div id="logger"></div>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>

var polygons, link, site, voronoi, sites, diagram;
var xNormA, yNormA, xNormB, yNormB;
var svg, viewWidth, viewHeight, width, height, scaleX, scaleY;

//log messages to console and to the view
function log(msg) {
	var logger = document.getElementById("logger");
	logger.innerHTML = logger.innerHTML + "<br/>" + msg;
	console.log(msg);
}

//returns a function that generates in a given distribution
function gaussian(mean, stdev) {
    var y2;
    var use_last = false;
    return function() {
        var y1;
        if(use_last) {
           y1 = y2;
           use_last = false;
        }
        else {
            var x1, x2, w;
            do {
                 x1 = 2.0 * Math.random() - 1.0;
                 x2 = 2.0 * Math.random() - 1.0;
                 w  = x1 * x1 + x2 * x2;               
            } while( w >= 1.0);
            w = Math.sqrt((-2.0 * Math.log(w))/w);
            y1 = x1 * w;
            y2 = x2 * w;
            use_last = true;
       }

       var retval = mean + stdev * y1;
       if(retval > 0) 
           return retval;
       return -retval;
   }
}

//pick out points in a distribution that looks nice
function pointGen() {
	var point;
	if(Math.random() < .5) {
		point = [xNormA(), yNormA()]
	} else {
		point = [xNormB(), yNormB()]
	}
	return point;
}

//for each faction, start in a random location and expand from there
function assignFactions() {
	var factions = ['teamRed', 'teamBlue', 'teamGreen', 'teamYellow', 'teamOrange', 'teamCyan', 'teamPurple', 'teamBrown']
	factions.forEach(function (faction) {
		var index;
		while(!index) {
			index = Math.floor(Math.random() * diagram.cells.length);
			var cell = diagram.cells[index];
			if (cell.faction) {
				index = undefined;
			}
		}
		assignFaction(index, faction, .9, .25);
	});
}

//assign a faction to a cell, given by 'index'
//expand with a chance of 'expantion' to any given adjacent cells
//decrease rate of expantion by 'decrement'
function assignFaction(index, faction, expantion, decrement) {
	var cell = diagram.cells[index];
	//randomly assign a faction, for now one of two
	if(cell.faction) return;
	cell.faction = faction;
	polygons._groups[0][index].setAttribute("class", faction);
	//now, with a random chance, pick an adjacent cell and apply the faction if it doesn't have one
	cell.halfedges.forEach(function(hEdge) {
		//var hEdge = cell.halfedges[hEdgeIndex];
		//log("exploring cell " +index+" edge "+hEdgeIndex);
		if(Math.random() < expantion) {
			var edge = diagram.edges[hEdge];
			//find neighbor that is not the current cell
			var neighbor = edge.left;
			if (neighbor === cell.site || !neighbor){ 
				neighbor = edge.right;
			}
			//if we have a neighbor
			if(neighbor) {
				assignFaction(neighbor.index, faction, expantion * decrement, decrement);
			}
		}
	});
}

function assignDescriptions() {
	var aspects = getAspects();
	diagram.cells.forEach(function (cell) {
		var site = cell.site;
		//pick three aspects per site
		var aspects = [getDescription(), getDescription(), getDescription()];
		site.aspects = aspects;
	});
}

function getDescription() {
	var aspects = getAspects();
	return aspects[Math.floor(Math.random() * aspects.length)];
}

function init() {
	//view variables
	svg 		= d3.select("svg");
	viewWidth	= svg.attr("width");
	viewHeight	= svg.attr("height");
	width		= 1200;
	height		= 900;
	scaleX		= viewWidth/width;
	scaleY		= viewHeight/height;

	//Two distrubutions make it look interesting
	xNormA = gaussian(width/2 + width/8, width/10);
	yNormA = gaussian(height/2 - height/8, height/10);
	xNormB = gaussian(width/2 - width/8, width/10);
	yNormB = gaussian(height/2 + height/8, height/10);

	//main diagram references
	sites = d3.range(200).map(pointGen);
	voronoi = d3.voronoi().extent([[-1,-1], [width+1, height+1]]);
	diagram = voronoi(sites);

	//init the view
	polygons = svg.append("g")
		.attr("class", "polygons")
		.selectAll("path")
		.data(voronoi.polygons(sites))
		.enter()
		.append("path")
		.call(redrawPolygon);
	link = svg.append("g")
		.attr("class", "links")
		.selectAll("line")
		.data(voronoi.links(sites))
		.enter()
		.append("line")
		.call(redrawLink);
	site = svg.append("g")
		.attr("class", "sites")
		.selectAll("circle")
		.data(sites)
		.enter()
		.append("circle")
		.attr("r", 2.5)
		.call(redrawSite);

	assignFactions();
	assignDescriptions();
}

//draw a region
function redrawPolygon(polygon) {
	//console.log(polygon);
	polygon.attr("d", function(d) {
		return d ? "M" + d.map(function(i) {
				return [i[0]*scaleX, i[1]*scaleY];
			}).join("L") + "Z" : null;
		})
		.on("mouseover", function() { this.setAttribute("style", "fill-opacity: .5"); })
		.on("mouseout", function() { this.setAttribute("style", "fill-opacity: .2"); })
		.on("mousedown", showDetails);
}
//draw a star lane
function redrawLink(link) {
	link
		.attr("x1", function(d) { return d.source[0]*scaleX; })
		.attr("y1", function(d) { return d.source[1]*scaleY; })
		.attr("x2", function(d) { return d.target[0]*scaleX; })
		.attr("y2", function(d) { return d.target[1]*scaleY; });
}
//draw a star/planet
function redrawSite(site) {
	site
		.attr("cx", function(d) { return d[0]*scaleX; })
		.attr("cy", function(d) { return d[1]*scaleY; });
}

function showDetails() {
	var site = diagram.find(d3.mouse(this)[0], d3.mouse(this)[1]);
	var details = document.getElementById("details");
	details.innerText = site.aspects.join(", ");
}

function getAspects() {
	return [
		'high gravity',
		'normal gravity', 
		'low gravity',
		'industrialized',
		'mechanized',
		'agrarian',
		'peaceful',
		'agressive',
		'xenophobic',
		'welcoming',
		'wealthy',
		'poor',
		'monarchy',
		'democracy',
		'religious',
		'ecologist',
		'scientists',
		'pacifist',
		'authoritarian',
		'xenophile',
		'greedy',
		'communistic',
		'outpost',
		'colony',
		'homeworld',
		'spacefaring',
		'robotic',
		'bioengeered',
		'desert',
		'swamp',
		'oceans',
		'icey',
		'water-covered',
		'underwater',
		'jungle',
		'forest',
		'confederation',
		'anarchy',
		'empire',
		'hegemony',
		'theocracy',
		'tidaly-locked',
		'asteroid',
		'moon',
		'capital',
		'gas giant',
		'arborial',
		'natives',
		'plantShaper'
	]
}

window.onload = function() { init(); };

</script>
